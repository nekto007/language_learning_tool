{% extends "base.html" %}

{% block title %}{{ _('Flashcards') }}{% endblock %}

{% block content %}
<div class="container mt-4" id="flashcard-app">
    <!-- Progress bar and stats -->
    <div class="card shadow-sm mb-4">
        <div class="card-body">
            <div class="d-flex justify-content-between align-items-center mb-3">
                <div>
                    <h2 class="h5 fw-bold mb-1">{{ _('Study Progress') }}</h2>
                    <p class="text-secondary mb-0 small" id="card-counter">{{ _('Card 1 of 20') }}</p>
                </div>
                <div class="d-flex align-items-center gap-3">
                    <div class="d-flex gap-2">
                        <span class="badge bg-info" id="new-cards-counter" title="{{ _('New cards') }}">{{ _('Новых') }}: 0</span>
                        <span class="badge bg-success" id="studied-cards-counter" title="{{ _('Studied cards') }}">{{ _('Изучено') }}: 0</span>
                        <span class="badge bg-warning" id="review-cards-counter" title="{{ _('Review cards') }}">{{ _('Повторить') }}: 0</span>
                    </div>
                    <button id="end-session-btn" class="btn btn-outline-secondary btn-sm">{{ _('End Session') }}</button>
                </div>
            </div>
            <div class="progress" style="height: 10px;">
                <div class="progress-bar bg-success" id="progress-fill" style="width: 0%; transition: width 0.3s ease;"></div>
            </div>
        </div>
    </div>

    <!-- Loading spinner -->
    <div id="loading-spinner" class="text-center py-5">
        <div class="spinner-border text-primary" role="status">
            <span class="visually-hidden">{{ _('Loading...') }}</span>
        </div>
        <p class="mt-2 text-muted">{{ _('Loading cards...') }}</p>
    </div>

    <!-- Cards container -->
    <div id="flashcard-view" style="display: none;">
        <!-- Front side (question) -->
        <div id="card-front" class="card shadow-sm mb-4 text-center" style="min-height: 400px; padding: 40px 30px; position: relative;">
            <div class="card-body d-flex flex-column align-items-center justify-content-center">
                <h1 id="front-word" class="display-3 mb-4 fw-medium"></h1>

                <button id="front-audio-btn" class="btn btn-outline-secondary mb-4">
                    <i class="fas fa-volume-up me-2"></i> {{ _('Pronunciation') }}
                </button>

                <p id="hint-text" class="text-secondary fs-5 my-4 hint-text"></p>

                <button id="show-answer-btn" class="btn btn-primary btn-lg mt-auto">
                    {{ _('Show Answer') }}
                </button>
            </div>
        </div>

        <!-- Back side (answer) -->
        <div id="card-back" class="card shadow-sm mb-4 text-center" style="display: none; min-height: 400px; padding: 40px 30px; position: relative;">
            <div class="card-body">
                <h1 id="back-word" class="display-3 mb-4 fw-medium"></h1>

                <button id="back-audio-btn" class="btn btn-outline-secondary mb-4">
                    <i class="fas fa-volume-up me-2"></i> {{ _('Pronunciation') }}
                </button>

                <hr class="my-4" style="max-width: 500px; margin-left: auto; margin-right: auto;">

                <div class="mb-4">
                    <div class="text-secondary mb-2 fw-semibold">{{ _('Translation') }}</div>
                    <div id="translation-text" class="fs-4 text-danger"></div>
                </div>

                <div id="examples-container" class="mb-4">
                    <div class="text-secondary mb-2 fw-semibold">{{ _('Examples') }}</div>
                    <div id="example-text" class="mb-2"></div>
                    <div id="example-translation" class="text-secondary"></div>
                </div>

                <div class="d-flex justify-content-center gap-2 mt-4">
                    <button type="button" class="btn btn-danger flex-fill" style="max-width: 200px;" data-rating="0">
                        {{ _('Снова') }}
                </button>
                <button type="button" class="rating-btn btn-hard" data-rating="2">
                    {{ _('Трудно') }}
                </button>
                <button type="button" class="rating-btn btn-easy" data-rating="4">
                    {{ _('Легко') }}
                </button>
            </div>
        </div>

        <!-- Сообщение о завершении дневного лимита -->
        <div id="daily-limit-message" class="card-container text-center" style="display: none;">
            <h2 class="mb-4 text-success">
                <i class="fas fa-check-circle text-success me-2"></i>
                {{ _('Hooray! You\'re done for today.') }}
            </h2>

            <div class="mb-4">{{ _('Today\'s study limit has been reached. There are still new cards, but the daily limit is exhausted. You can increase the limit in the settings, but please keep in mind that the more new cards you see, the more you\'ll need to review in the near future.') }}</div>
            <div class="mt-4">
                <div class="d-flex justify-content-center gap-3 mb-4">
                    <div class="text-center">
                        <h4 id="new-cards-stats" class="mb-2">0 / 0</h4>
                        <p class="text-muted">{{ _('New cards') }}</p>
                    </div>
                    <div class="text-center">
                        <h4 id="reviews-stats" class="mb-2">0 / 0</h4>
                        <p class="text-muted">{{ _('Reviews') }}</p>
                    </div>
                </div>
            </div>

            <div class="mt-4">
                <a href="{{ url_for('study.cards', word_source='new') }}?extra_study=true" class="btn btn-primary">
                    <i class="fas fa-plus me-2"></i> {{ _('Start Extra Study') }}
                </a>

                <a href="{{ url_for('study.index') }}" class="btn btn-outline-secondary ms-2">
                    {{ _('Return to Dashboard') }}
                </a>

                <a href="{{ url_for('study.settings') }}" class="btn btn-outline-secondary ms-2">
                    <i class="fas fa-cog"></i> {{ _('Settings') }}
                </a>
            </div>
        </div>

        <!-- No cards message -->
        <div id="no-cards-message" class="alert alert-info text-center" style="display: none;">
            <h4>{{ _('No Cards Available') }}</h4>
            <p>{{ _('There are no words matching your study criteria.') }}</p>
            <a href="{{ url_for('study.index') }}" class="btn btn-primary mt-2">
                {{ _('Return to Study Dashboard') }}
            </a>
        </div>

        <!-- Session complete message -->
        <div id="session-complete" class="card-container text-center" style="display: none;">
            <h2 class="mb-4">
                <i class="fas fa-check-circle text-success me-2"></i>
                {{ _('Session Complete!') }}
            </h2>
            <div class="row mt-4">
                <div class="col-md-4">
                    <h2 id="stats-words" class="text-primary">0</h2>
                    <p class="text-muted">{{ _('Cards Studied') }}</p>
                </div>
                <div class="col-md-4">
                    <h2 id="stats-correct" class="text-success">0</h2>
                    <p class="text-muted">{{ _('Correct Answers') }}</p>
                </div>
                <div class="col-md-4">
                    <h2 id="stats-score" class="text-warning">0%</h2>
                    <p class="text-muted">{{ _('Score') }}</p>
                </div>
            </div>

            <div class="mt-5">
                <a href="{{ url_for('study.index') }}" class="btn btn-primary">
                    {{ _('Back to Study') }}
                </a>
                <a href="{{ url_for('study.cards') }}" class="btn btn-outline-secondary ms-2">
                    {{ _('Start New Session') }}
                </a>
            </div>
        </div>
    </div>
</div>

<!-- Audio element (hidden) -->
<audio id="word-audio" style="display: none;"></audio>
{% endblock %}

{% block scripts %}
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Config from server
        const sessionId = {{ session_id }};
        const wordSource = '{{ word_source }}';
        const showTranslations = {{ settings.include_translations|lower }};
        const showExamples = {{ settings.include_examples|lower }};
        const playAudio = {{ settings.include_audio|lower }};
        const hintTime = 7; // Фиксированное время показа подсказки - 5 секунд

        // App state
        let originalCards = []; // Original cards from API
        let cards = [];         // Processed cards with both directions
        let currentCardIndex = 0;
        let sessionStartTime = Date.now();
        let sessionStats = {
            total: 0,
            correct: 0,
            incorrect: 0,
            new_cards: 0,
            review_cards: 0
        };
        let hintTimeout = null;

        // DOM elements
        const flashcardView = document.getElementById('flashcard-view');
        const cardFront = document.getElementById('card-front');
        const cardBack = document.getElementById('card-back');
        const frontWord = document.getElementById('front-word');
        const backWord = document.getElementById('back-word');
        const frontAudioBtn = document.getElementById('front-audio-btn');
        const backAudioBtn = document.getElementById('back-audio-btn');
        const translationText = document.getElementById('translation-text');
        const examplesContainer = document.getElementById('examples-container');
        const exampleText = document.getElementById('example-text');
        const exampleTranslation = document.getElementById('example-translation');
        const hintText = document.getElementById('hint-text');
        const cardCounter = document.getElementById('card-counter');
        const correctCounter = document.getElementById('correct-counter');
        const incorrectCounter = document.getElementById('incorrect-counter');
        const newCardsCounter = document.getElementById('new-cards-counter');
        const studiedCardsCounter = document.getElementById('studied-cards-counter');
        const reviewCardsCounter = document.getElementById('review-cards-counter');
        const progressFill = document.getElementById('progress-fill');
        const showAnswerBtn = document.getElementById('show-answer-btn');
        const loadingSpinner = document.getElementById('loading-spinner');
        const noCardsMessage = document.getElementById('no-cards-message');
        const dailyLimitMessage = document.getElementById('daily-limit-message');
        const sessionComplete = document.getElementById('session-complete');
        const wordAudio = document.getElementById('word-audio');
        const endSessionBtn = document.getElementById('end-session-btn');
        const newCardsStats = document.getElementById('new-cards-stats');
        const reviewsStats = document.getElementById('reviews-stats');

        // Stats elements
        const statsWords = document.getElementById('stats-words');
        const statsCorrect = document.getElementById('stats-correct');
        const statsScore = document.getElementById('stats-score');

        // Fetch cards from the API
        async function fetchCards() {
            try {
                // Проверяем, запрошено ли дополнительное занятие
                const extraStudy = new URLSearchParams(window.location.search).get('extra_study') === 'true';

                // Добавляем параметр в запрос, если это дополнительное занятие
                const url = `/study/api/get-study-items?source=${wordSource}${extraStudy ? '&extra_study=true' : ''}`;

                console.log('Fetching cards from:', url);
                const response = await fetch(url);

                console.log('API Response status:', response.status);

                if (!response.ok) {
                    throw new Error('Failed to fetch cards');
                }

                const data = await response.json();
                console.log('API response data:', data);

                // Проверяем статус ответа
                if (data.status === 'daily_limit_reached') {
                    console.log('Daily limit reached. Showing message.');
                    showDailyLimitMessage(data.stats);
                    // Устанавливаем флаг, что сообщение показано
                    window.noCardsMessageShown = true;
                    return [];
                }

                if (data.status === 'success' && (!data.items || data.items.length === 0)) {
                    console.log('No items in selected source. Checking stats.');

                    // Проверяем, есть ли еще доступный лимит для изучения
                    const remainingNewCards = data.stats.new_cards_limit - data.stats.new_cards_today;
                    const remainingReviews = data.stats.reviews_limit - data.stats.reviews_today;

                    if (remainingNewCards > 0 || remainingReviews > 0) {
                        // Если еще есть лимит для изучения, показываем сообщение о том,
                        // что в этом источнике нет карточек, но можно попробовать другие источники
                        showNoCardsInSourceMessage(data.stats);
                        // Устанавливаем флаг, что сообщение показано
                        window.noCardsMessageShown = true;
                    } else {
                        // Если лимиты исчерпаны, показываем стандартное сообщение об отсутствии карточек
                        showNoCardsMessage();
                        // Устанавливаем флаг, что сообщение показано
                        window.noCardsMessageShown = true;
                    }
                    return [];
                }

                // Применяем фильтрацию к полученным карточкам
                const filteredData = data.items.filter(card => card.translation && card.translation.trim() !== '');
                console.log('After filtering for translations:', filteredData.length);

                return filteredData;
            } catch (error) {
                console.error('Error fetching cards:', error);
                showNoCardsMessage();
                // Устанавливаем флаг, что сообщение показано
                window.noCardsMessageShown = true;
                return [];
            }
        }

        function showNoCardsInSourceMessage(stats) {
            console.log('Showing no cards in source message with stats:', stats);

            // Сначала скрываем все контейнеры
            loadingSpinner.style.display = 'none';
            if (cardFront) cardFront.style.display = 'none';
            if (cardBack) cardBack.style.display = 'none';
            if (noCardsMessage) noCardsMessage.style.display = 'none';
            if (sessionComplete) sessionComplete.style.display = 'none';
            if (dailyLimitMessage) dailyLimitMessage.style.display = 'none';

            // Показываем flashcardView, так как в нем находится наше сообщение
            flashcardView.style.display = 'block';

            // Находим элемент сообщения
            const noCardsInSourceMessage = document.getElementById('no-cards-in-source-message');

            if (noCardsInSourceMessage) {
                console.log('Found no-cards-in-source-message element, displaying it');

                // Обновляем статистику
                const availableNewCards = document.getElementById('available-new-cards');
                if (availableNewCards) {
                    const remaining = stats.new_cards_limit - stats.new_cards_today;
                    availableNewCards.textContent = `${remaining} / ${stats.new_cards_limit}`;
                }

                const availableReviews = document.getElementById('available-reviews');
                if (availableReviews) {
                    const remaining = stats.reviews_limit - stats.reviews_today;
                    availableReviews.textContent = `${remaining} / ${stats.reviews_limit}`;
                }

                // Показываем сообщение и используем setTimeout для небольшой задержки
                // чтобы убедиться, что DOM полностью обновлен
                setTimeout(() => {
                    noCardsInSourceMessage.style.display = 'block';
                    console.log('Message display style set to block');

                    // Дополнительная защита: повторно проверим через 100мс
                    setTimeout(() => {
                        if (noCardsInSourceMessage.style.display !== 'block') {
                            console.log('Message was hidden, showing again');
                            noCardsInSourceMessage.style.display = 'block';
                        }
                    }, 100);
                }, 50);
            } else {
                console.log('Could not find no-cards-in-source-message element');
                // Если элемент не найден, показываем сообщение в noCardsMessage
                if (noCardsMessage) {
                    noCardsMessage.innerHTML = `
                        <h4>{{ _('No Cards in This Section') }}</h4>
                        <p>{{ _('There are no available words to study in the selected source.') }}</p>
                        <div class="alert alert-info my-3">
                            <p>{{ _('You still have your daily limit available. Try selecting a different card source or start learning new words.') }}</p>
                        </div>
                        <div class="mt-4">
                            <a href="{{ url_for('study.cards', word_source='new') }}" class="btn btn-primary">
                                <i class="fas fa-plus me-2"></i> {{ _('Study New Words') }}
                            </a>
                            <a href="{{ url_for('study.cards', word_source='all') }}" class="btn btn-outline-primary ms-2">
                                <i class="fas fa-random me-2"></i> {{ _('Mixed Mode') }}
                            </a>
                            <a href="{{ url_for('study.index') }}" class="btn btn-outline-secondary ms-2">
                                {{ _('Back to Study') }}
                            </a>
                        </div>
                    `;

                    // Используем setTimeout для показа, чтобы избежать конфликтов с другим кодом
                    setTimeout(() => {
                        noCardsMessage.style.display = 'block';
                        console.log('Fallback message displayed');
                    }, 5);
                }
            }

            // Предотвращаем дальнейшую инициализацию карточек
            // Это важно! Добавляем флаг, что мы уже показали сообщение
            window.noCardsMessageShown = true;
        }


        // Create alternating cards (eng-rus, rus-eng) from original cards
        function createAlternatingCards(originalCards) {
            if (!originalCards || originalCards.length === 0) {
                console.log('No original cards to process');
                return [];
            }

            console.log('Creating alternating cards from:', originalCards.length, 'original cards');
            const alternatingCards = [];

            // Process each original card
            for (const card of originalCards) {
                const isWordEnglish = /^[A-Za-z\s,]+$/.test(card.word);
                if (isWordEnglish) {
                    // Create eng-rus card
                    alternatingCards.push({
                        ...card,
                        direction:  'eng-rus',
                        word:       card.word,
                        translation:card.translation
                    });

                    alternatingCards.push({
                        ...card,
                        direction:  'rus-eng',
                        word:       card.translation,
                        translation:card.word
                    });
                } else {
                    alternatingCards.push({
                        ...card,
                        direction: 'rus-eng',
                        word: card.word,
                        translation: card.translation
                    });

                    alternatingCards.push({
                        ...card,
                        direction: 'eng-rus',
                        word: card.translation,
                        translation: card.word
                    });
                }
            }

            console.log('Created', alternatingCards.length, 'alternating cards');
            // Shuffle the cards while keeping pairs of the same word separated
            return shuffleCards(alternatingCards);
        }

        // Shuffle cards while keeping same words apart from each other
        function shuffleCards(cards) {
            if (!cards || cards.length === 0) {
                console.log('No cards to shuffle');
                return [];
            }

            // Group cards by word_id
            const cardsByWordId = {};
            for (const card of cards) {
                if (!cardsByWordId[card.word_id]) {
                    cardsByWordId[card.word_id] = [];
                }
                cardsByWordId[card.word_id].push(card);
            }

            // Create shuffled word_id array
            const wordIds = Object.keys(cardsByWordId);
            for (let i = wordIds.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [wordIds[i], wordIds[j]] = [wordIds[j], wordIds[i]];
            }

            // Rebuild cards array with alternating directions
            const shuffledCards = [];
            const directions = ['eng-rus', 'rus-eng'];
            let directionIndex = 0;

            for (const wordId of wordIds) {
                const cardsForWord = cardsByWordId[wordId];
                // Find card with current direction
                const engToRusCard = cardsForWord.find(c => c.direction === 'eng-rus');
                const rusToEngCard = cardsForWord.find(c => c.direction === 'rus-eng');

                // Add current direction first
                const currentDirection = directions[directionIndex % 2];
                if (currentDirection === 'eng-rus') {
                    shuffledCards.push(engToRusCard);
                    shuffledCards.push(rusToEngCard);
                } else {
                    shuffledCards.push(rusToEngCard);
                    shuffledCards.push(engToRusCard);
                }

                // Alternate starting direction for next word
                directionIndex++;
            }

            console.log('Shuffled cards:', shuffledCards.length);
            return shuffledCards;
        }

        // Format hint with first letter and underscores showing the length of the word
        function formatHint(word) {
            if (!word || word.length === 0) return '';

            // If there are multiple translations separated by commas, take the first one
            let targetWord = word;
            if (word.includes(',')) {
                targetWord = word.split(',')[0].trim();
            }

            const firstChar = targetWord.charAt(0).toLowerCase();
            const underscores = '_'.repeat(8); // Just show fixed number of underscores like in the screenshot
            const letterCount = targetWord.length;

            // Format for Russian word endings
            let letterForm = '{{ _("letters") }}';
            const lastDigit = letterCount % 10;

            if (letterCount % 100 >= 11 && letterCount % 100 <= 19) {
                letterForm = '{{ _("letters") }}';
            } else if (lastDigit === 1) {
                letterForm = '{{ _("letter") }}';
            } else if (lastDigit >= 2 && lastDigit <= 4) {
                letterForm = '{{ _("letters_2-4") }}';
            }

            return `{{ _("Hint:") }} ${firstChar}${underscores} (${letterCount} ${letterForm})`;
        }

        // Show daily limit reached message
        function showDailyLimitMessage(stats) {
            loadingSpinner.style.display = 'none';
            flashcardView.style.display = 'block';
            cardFront.style.display = 'none';
            cardBack.style.display = 'none';
            noCardsMessage.style.display = 'none';
            sessionComplete.style.display = 'none';

            // Обновляем статистику
            if (newCardsStats) {
                newCardsStats.textContent = `${stats.new_cards_today} / ${stats.new_cards_limit}`;
            }

            if (reviewsStats) {
                reviewsStats.textContent = `${stats.reviews_today} / ${stats.reviews_limit}`;
            }

            // Показываем сообщение о дневном лимите
            dailyLimitMessage.style.display = 'block';
        }

        // Initialize the flashcard app
        async function initApp() {
            console.log('Initializing flashcard app');

            try {
                // Fetch original cards
                originalCards = await fetchCards();
                console.log('Fetched original cards:', originalCards ? originalCards.length : 0);

                // Проверяем флаг - если сообщение уже показано, прекращаем инициализацию
                if (window.noCardsMessageShown) {
                    console.log('Message already shown, stopping initialization');
                    return;
                }

                if (!originalCards || originalCards.length === 0) {
                    console.log('No cards available');
                    return;
                }

                // Create alternating cards
                cards = createAlternatingCards(originalCards);
                console.log('Created cards array with length:', cards ? cards.length : 0);

                if (!cards || cards.length === 0) {
                    console.log('No cards after processing');
                    return;
                }

                // Count new and review cards
                let newCount = 0;
                let reviewCount = 0;
                
                for (let card of cards) {
                    if (card.is_new) {
                        newCount++;
                    } else {
                        reviewCount++;
                    }
                }
                
                sessionStats.new_cards = newCount;
                sessionStats.review_cards = reviewCount;
                
                // Update counters
                if (newCardsCounter) {
                    newCardsCounter.textContent = `{{ _('Новых') }}: ${newCount}`;
                }
                if (studiedCardsCounter) {
                    studiedCardsCounter.textContent = `{{ _('Изучено') }}: 0`;
                }
                if (reviewCardsCounter) {
                    reviewCardsCounter.textContent = `{{ _('Повторить') }}: ${reviewCount}`;
                }

                // Update UI
                loadingSpinner.style.display = 'none';
                flashcardView.style.display = 'block';

                // Show first card
                showCard(0);
            } catch (error) {
                console.error('Error during initialization:', error);
                loadingSpinner.style.display = 'none';
                noCardsMessage.style.display = 'block';
            }
        }

        // Display a card
        function showCard(index) {
            console.log('Showing card at index:', index, 'out of', cards.length);

            if (!cards || cards.length === 0) {
                console.log('No cards to show');
                showNoCardsMessage();
                return;
            }

            if (index >= cards.length) {
                console.log('End of cards reached, completing session');
                completeSession();
                return;
            }

            const card = cards[index];
            currentCardIndex = index;
            console.log(card.direction, card.word, card.translation);
            // Update progress
            const progress = ((index + 1) / cards.length) * 100;
            progressFill.style.width = `${progress}%`;
            cardCounter.textContent = `{{ _('Card') }} ${index + 1} {{ _('of') }} ${cards.length}`;

            // Reset card state
            cardFront.style.display = 'flex';
            cardBack.style.display = 'none';
            showAnswerBtn.style.display = 'block';
            hintText.classList.remove('visible');

            // Clear previous hint timeout
            if (hintTimeout) {
                clearTimeout(hintTimeout);
            }
            frontAudioBtn.hidden = true;  // прячем «произношение» спереди
            backAudioBtn.hidden  = true;  // и сзади, пока не решим иначе

            // Configure audio buttons
            const hasAudio = card.audio_url !== null;

            const isEngToRu = card.direction === 'eng-rus';

            // Set card content based on direction
            frontWord.textContent = card.word;        // всегда word
            backWord.textContent  = card.word;        // тоже word
            translationText.textContent = card.translation;

            // подсказка
            hintText.textContent = formatHint(card.translation);

            if (hasAudio && playAudio) {
                // Настраиваем аудио источник
                if (card.audio_url) {
                    wordAudio.src = card.audio_url;
                }
                
                // Логика показа кнопок аудио и автовоспроизведения
                if (card.direction === 'eng-rus') {
                    // Для eng-rus карточек показываем кнопку на фронтальной стороне
                    frontAudioBtn.hidden = false;
                    backAudioBtn.hidden = false; // Также доступно на обратной стороне
                    
                    // Автовоспроизведение для eng-rus карточек на фронтальной стороне
                    setTimeout(() => {
                        wordAudio.play().catch(error => {
                            console.log('Auto-play prevented:', error);
                        });
                    }, 300);
                } else {
                    // Для rus-eng карточек НЕ показываем кнопку на фронтальной стороне
                    frontAudioBtn.hidden = true;
                    backAudioBtn.hidden = false; // Показываем только на обратной стороне
                    
                    // НЕТ автовоспроизведения на фронтальной стороне для rus-eng
                }
            } else {
                frontAudioBtn.hidden = true;
                backAudioBtn.hidden = true;
            }

            // Show hint after 5 seconds
            hintTimeout = setTimeout(() => {
                hintText.classList.add('visible');
            }, hintTime * 1000);

            // Set example if available
            if (showExamples && card.examples) {
                const example = extractExampleParts(card.examples);

                exampleText.textContent = example.en;
                exampleTranslation.textContent = example.ru;
                examplesContainer.style.display = 'block';
            } else {
                examplesContainer.style.display = 'none';
            }
        }

        // Extract English and Russian parts from examples
        function extractExampleParts(examples) {
            if (!examples) return { en: '', ru: '' };

            // Replace HTML tags with nothing
            // const cleanedExamples = examples.replace(/<[^>]*>/g, '');
            const withNewlines = examples.replace(/<br\s*\/?>/gi, '\n');
            const cleanedExamples = withNewlines.replace(/<[^>]*>/g, '');

            // Split by newlines first
            let lines = cleanedExamples.split('\n').filter(line => line.trim() !== '');

            if (lines.length >= 2) {
                return {
                    en: lines[0].trim(),
                    ru: lines[1].trim()
                };
            }

            // Check if there's a dash at the beginning of a line
            lines = cleanedExamples.split(/\n\s*-\s*/).filter(line => line.trim() !== '');
            if (lines.length >= 2) {
                return {
                    en: lines[0].trim(),
                    ru: lines[1].trim()
                };
            }

            // If no obvious separator found, try to detect if there's English and Russian text
            // This is a simplified approach - assumes English has Latin characters and Russian has Cyrillic
            const hasCyrillic = /[А-Яа-я]/.test(cleanedExamples);
            const hasLatin = /[A-Za-z]/.test(cleanedExamples);

            if (hasCyrillic && hasLatin) {
                // Try to split by common punctuation that might separate examples
                const parts = cleanedExamples.split(/[;.]\s*/).filter(part => part.trim() !== '');

                // Find first part with Latin and first part with Cyrillic
                const enPart = parts.find(part => /[A-Za-z]/.test(part)) || '';
                const ruPart = parts.find(part => /[А-Яа-я]/.test(part)) || '';

                return {
                    en: enPart.trim(),
                    ru: ruPart.trim()
                };
            }

            // If nothing else works, just return the whole text
            return {
                en: cleanedExamples.trim(),
                ru: ''
            };
        }

        // Flip card to show answer
        function flipCard() {
            console.log('Flipping card');
            cardFront.style.display = 'none';
            cardBack.style.display = 'flex';

            // Clear hint timeout
            if (hintTimeout) {
                clearTimeout(hintTimeout);
                hintTimeout = null;
            }

            // Автовоспроизведение аудио при показе ответа для rus-eng карточек
            const card = cards[currentCardIndex];
            if (card.direction === 'rus-eng' && card.audio_url && playAudio) {
                setTimeout(() => {
                    wordAudio.play().catch(e => console.log('Auto-play on answer prevented:', e));
                }, 300);
            }
        }

        // Rate a card and move to the next
        async function rateCard(quality) {
            console.log('Rating card with quality:', quality);
            if (!cards || currentCardIndex >= cards.length) {
                console.error('Cannot rate card - invalid card index');
                return;
            }
            const csrfMeta = document.querySelector('meta[name="csrf-token"]');
            const csrfToken = csrfMeta && csrfMeta.content;
            const card = cards[currentCardIndex];

            // Implement card shuffling for "Again" rating to avoid immediate repetition
            if (quality === 0) {
                // "Снова" - shuffle remaining cards to avoid showing the same card immediately
                const remainingCards = cards.slice(currentCardIndex + 1);
                if (remainingCards.length > 1) {
                    // Shuffle remaining cards
                    for (let i = remainingCards.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [remainingCards[i], remainingCards[j]] = [remainingCards[j], remainingCards[i]];
                    }
                    // Replace remaining cards in the original array
                    cards.splice(currentCardIndex + 1, remainingCards.length, ...remainingCards);
                    console.log('Cards shuffled after "Again" rating to avoid immediate repetition');
                }
            }

            try {
                // Send rating to server with direction
                const response = await fetch('/study/api/update-study-item', {
                    method: 'POST',
                    credentials: 'same-origin',
                    headers: {
                        'Content-Type': 'application/json',
                        ...(csrfToken && { 'X-CSRFToken': csrfToken }),
                    },
                    body: JSON.stringify({
                        word_id: card.word_id,
                        direction: card.direction,  // Include the direction
                        quality: quality,
                        session_id: sessionId
                    }),
                });


                const data = await response.json();
                console.log('Rating response:', data);

                // Update session stats
                sessionStats.total++;

                // Update simplified counters based on user request
                if (card.is_new) {
                    sessionStats.new_cards--;
                    if (newCardsCounter) {
                        newCardsCounter.textContent = `{{ _('Новых') }}: ${Math.max(0, sessionStats.new_cards)}`;
                    }
                } else {
                    sessionStats.review_cards--;
                    if (reviewCardsCounter) {
                        reviewCardsCounter.textContent = `{{ _('Повторить') }}: ${Math.max(0, sessionStats.review_cards)}`;
                    }
                }
                
                // Update studied cards counter
                const studiedCount = sessionStats.total;
                if (studiedCardsCounter) {
                    studiedCardsCounter.textContent = `{{ _('Изучено') }}: ${studiedCount}`;
                }

                // Move to next card
                showCard(currentCardIndex + 1);

            } catch (error) {
                console.error('Error rating card:', error);
                alert('{{ _("Failed to save your rating. Please try again.") }}');
            }
        }

        // Complete the study session
        async function completeSession() {
            console.log('Completing session, session ID:', sessionId);
            try {
                const response = await fetch('/study/api/complete-session', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        session_id: sessionId
                    }),
                });

                const data = await response.json();
                console.log('Session completion response:', data);

                if (data.success) {
                    // Hide flashcard and show completion screen
                    cardFront.style.display = 'none';
                    cardBack.style.display = 'none';
                    sessionComplete.style.display = 'flex';

                    // Update stats display
                    statsWords.textContent = data.stats.words_studied;
                    statsCorrect.textContent = data.stats.correct;
                    statsScore.textContent = data.stats.percentage + '%';
                }

            } catch (error) {
                console.error('Error completing session:', error);
                // На случай ошибки всё равно перенаправим на главную страницу
                window.location.href = '{{ url_for("study.index") }}';
            }
        }

        // Show "no cards" message
        function showNoCardsMessage() {
            console.log('Showing no cards message');
            loadingSpinner.style.display = 'none';
            noCardsMessage.style.display = 'block';
        }

        // Event Listeners
        showAnswerBtn.addEventListener('click', function() {
            flipCard();
        });

        // Audio button clicks
        frontAudioBtn.addEventListener('click', function(e) {
            wordAudio.play();
        });

        backAudioBtn.addEventListener('click', function(e) {
            wordAudio.play();
        });

        // Rating buttons
        document.querySelectorAll('.rating-btn').forEach(button => {
            button.addEventListener('click', function() {
                const rating = parseInt(this.getAttribute('data-rating'));
                rateCard(rating);
            });
        });

        // End session early
        endSessionBtn.addEventListener('click', function() {
            console.log('End session button clicked');
            if (confirm('{{ _("Are you sure you want to end the session?") }}')) {
                try {
                    completeSession();
                } catch(e) {
                    console.error('Error in complete session:', e);
                    // Если что-то пошло не так, просто перенаправим на главную
                    window.location.href = '{{ url_for("study.index") }}';
                }
            }
        });

        // Keyboard shortcuts for rating cards
        document.addEventListener('keydown', function(e) {
            // Rating shortcuts when card back is visible
            if (cardBack.style.display === 'flex') {
                if (e.key === '1') {
                    e.preventDefault();
                    rateCard(0); // Снова
                } else if (e.key === '2') {
                    e.preventDefault();
                    rateCard(2); // Трудно
                } else if (e.key === '3') {
                    e.preventDefault();
                    rateCard(4); // Легко
                }
            }
            // Show answer when front card is visible and spacebar is pressed
            else if (cardFront.style.display === 'flex' && e.code === 'Space') {
                e.preventDefault();
                flipCard();
            }
            // Ctrl+Shift+X для экстренного выхода
            else if (e.ctrlKey && e.shiftKey && e.key === 'X') {
                console.log('Emergency exit triggered');
                window.location.href = '{{ url_for("study.index") }}';
            }
        });

        // Initialize the app
        console.log('Starting application initialization');
        initApp();
    });
</script>
{% endblock %}