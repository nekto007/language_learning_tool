{% extends "lesson_base_template.html" %}

{% set component_name = _('–§–∏–Ω–∞–ª—å–Ω—ã–π —Ç–µ—Å—Ç') %}
{% set instruction_text = _('–û—Ç–≤–µ—Ç—å—Ç–µ –Ω–∞ –≤—Å–µ –≤–æ–ø—Ä–æ—Å—ã, —á—Ç–æ–±—ã –∑–∞–≤–µ—Ä—à–∏—Ç—å –º–æ–¥—É–ª—å. –ù–µ–æ–±—Ö–æ–¥–∏–º–æ –Ω–∞–±—Ä–∞—Ç—å –º–∏–Ω–∏–º—É–º ') ~ passing_score ~ _('%% –¥–ª—è —É—Å–ø–µ—à–Ω–æ–≥–æ –ø—Ä–æ—Ö–æ–∂–¥–µ–Ω–∏—è.') %}
{% set block_description = _('–§–∏–Ω–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –∑–Ω–∞–Ω–∏–π –ø–æ –≤—Å–µ–º—É –º–æ–¥—É–ª—é') %}
{% set show_score = true %}

{% block extra_css %}
<style>
/* Hide breadcrumb and header for clean look */
.lesson-breadcrumb,
.lesson-header,
.lesson-description,
.instruction-box {
  display: none !important;
}

.lesson-page {
  padding-top: 0.5rem !important;
  padding-bottom: 0.5rem !important;
}

.lesson-content {
  margin-top: 0 !important;
  padding-top: 0 !important;
}

/* Final test screens */
.final-test-screen {
  min-height: 300px;
}

.checkpoint-lesson {
  max-width: 1000px;
  margin: 0 auto;
}

/* Start screen */
.checkpoint-start-content {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 3rem 2rem;
  text-align: center;
}

.checkpoint-icon {
  font-size: 4rem;
  color: #dc2626;
  margin-bottom: 1.5rem;
}

.checkpoint-start-content h2 {
  font-size: 2rem;
  font-weight: 700;
  color: #1f2937;
  margin-bottom: 1rem;
}

.checkpoint-start-content p {
  font-size: 1.1rem;
  color: #6b7280;
  max-width: 500px;
  margin: 0 auto;
}

/* Info grid - horizontal layout */
.checkpoint-info {
  background: white;
  border-radius: 1rem;
  padding: 1.5rem;
  margin-bottom: 2rem;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.info-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 1.5rem;
}

.info-item {
  display: flex;
  align-items: center;
  gap: 1rem;
  padding: 1rem;
  background: linear-gradient(135deg, #f9fafb 0%, #f3f4f6 100%);
  border-radius: 0.75rem;
  border: 2px solid #e5e7eb;
}

.info-item i {
  font-size: 2rem;
  color: #dc2626;
  flex-shrink: 0;
}

.info-item > div {
  flex: 1;
}

.info-value {
  display: block;
  font-size: 1.75rem;
  font-weight: 700;
  color: #1f2937;
  line-height: 1;
  margin-bottom: 0.25rem;
}

.info-label {
  display: block;
  font-size: 0.875rem;
  color: #6b7280;
  font-weight: 500;
}

/* Warning message */
.checkpoint-warning {
  background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
  border-left: 4px solid #f59e0b;
  border-radius: 0.75rem;
  padding: 1.25rem 1.5rem;
  margin-bottom: 2rem;
  display: flex;
  align-items: start;
  gap: 1rem;
}

.checkpoint-warning i {
  font-size: 1.5rem;
  color: #d97706;
  flex-shrink: 0;
  margin-top: 0.125rem;
}

.checkpoint-warning p {
  margin: 0;
  color: #92400e;
  font-size: 1rem;
  font-weight: 500;
  line-height: 1.5;
}

/* Start button */
#start-final-test-btn {
  margin-top: 2rem;
  padding: 1rem 2rem;
  font-size: 1.1rem;
  font-weight: 600;
  background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%);
  border: none;
  border-radius: 0.75rem;
  color: white;
  cursor: pointer;
  transition: all 0.3s;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

#start-final-test-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 10px 25px rgba(220, 38, 38, 0.3);
}

/* Progress bar */
.final-test-progress-section {
  margin-bottom: 2rem;
}

.progress-info {
  text-align: center;
  font-size: 1.1rem;
  font-weight: 600;
  color: #1f2937;
  margin-bottom: 0.75rem;
}

.final-test-progress-bar {
  width: 100%;
  height: 12px;
  background: #e5e7eb;
  border-radius: 6px;
  overflow: hidden;
}

.final-test-progress-fill {
  height: 100%;
  background: linear-gradient(90deg, #dc2626, #ef4444);
  border-radius: 6px;
  transition: width 0.4s ease;
}

/* Question cards */
.question-card {
  background: white;
  border-radius: 1rem;
  padding: 1.5rem;
  box-shadow: 0 4px 6px rgba(0,0,0,0.1);
  max-width: 900px;
}

.question-text {
  font-size: 1.3rem;
  font-weight: 600;
  color: #1f2937;
  margin-bottom: 1.5rem;
  line-height: 1.3;
}

.answer-options {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}

.answer-option {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  padding: 1rem;
  background: white;
  border: 2px solid #e5e7eb;
  border-radius: 0.75rem;
  cursor: pointer;
  transition: all 0.3s;
  text-align: left;
  font-size: 1rem;
}

.answer-option:hover:not(:disabled) {
  border-color: #dc2626;
  background: #fef2f2;
  transform: translateX(5px);
}

.answer-option:disabled {
  cursor: not-allowed;
  opacity: 0.6;
}

.answer-option.correct {
  border-color: #10b981 !important;
  background: #d1fae5 !important;
}

.answer-option.incorrect {
  border-color: #ef4444 !important;
  background: #fee2e2 !important;
}

.answer-option.selected {
  transform: translateX(0) !important;
}

.option-letter {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 32px;
  height: 32px;
  background: #dc2626;
  color: white;
  border-radius: 50%;
  font-weight: 700;
  font-size: 0.95rem;
  flex-shrink: 0;
}

.option-text {
  flex: 1;
  color: #1f2937;
}

/* Question feedback */
.question-feedback {
  margin-top: 1rem;
  padding: 0.75rem 1rem;
  border-radius: 0.5rem;
  animation: slideIn 0.3s ease;
  max-width: 400px;
  margin-left: auto;
  margin-right: auto;
}

.question-feedback.correct {
  background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%);
  border: 2px solid #10b981;
}

.question-feedback.incorrect {
  background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%);
  border: 2px solid #ef4444;
}

.feedback-content {
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: center;
  gap: 0.5rem;
  text-align: center;
}

.feedback-icon {
  font-size: 1.5rem;
  line-height: 1;
  flex-shrink: 0;
}

.question-feedback.correct .feedback-icon {
  color: #10b981;
}

.question-feedback.incorrect .feedback-icon {
  color: #ef4444;
}

.feedback-text {
  font-size: 1rem;
  color: #1f2937;
  line-height: 1.5;
  margin: 0;
}

@keyframes slideIn {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Text input for translation/fill_blank */
.text-answer .form-control {
  padding: 0.875rem 1rem;
  font-size: 1rem;
  border: 2px solid #e5e7eb;
  border-radius: 0.5rem;
  transition: all 0.3s;
}

.text-answer .form-control:focus {
  outline: none;
  border-color: #dc2626;
  box-shadow: 0 0 0 3px rgba(220, 38, 38, 0.1);
}

.text-submit-btn {
  margin-top: 1rem !important;
  padding: 0.75rem 1.5rem !important;
  font-size: 1rem !important;
  background: #dc2626 !important;
  border: none !important;
  border-radius: 0.5rem !important;
}

.text-submit-btn:hover {
  background: #991b1b !important;
}

/* Reorder questions */
.words-container {
  display: flex;
  flex-wrap: wrap;
  gap: 0.75rem;
  padding: 1.5rem;
  background: #f9fafb;
  border-radius: 0.75rem;
  margin-bottom: 1.5rem;
  min-height: 100px;
  border: 2px dashed #d1d5db;
}

.word-button {
  padding: 0.75rem 1.25rem;
  background: white;
  border: 2px solid #e5e7eb;
  border-radius: 0.5rem;
  font-size: 1.05rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.3s;
  color: #1f2937;
}

.word-button:hover:not(:disabled) {
  border-color: #dc2626;
  background: #fef2f2;
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(220, 38, 38, 0.2);
}

.word-button:disabled,
.word-button.used {
  opacity: 0.4;
  cursor: not-allowed;
  background: #f3f4f6;
}

.sentence-display {
  min-height: 80px;
  padding: 1.5rem;
  background: white;
  border: 2px solid #dc2626;
  border-radius: 0.75rem;
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  gap: 0.5rem;
  cursor: pointer;
  transition: all 0.3s;
}

.sentence-display:hover {
  background: #fafafa;
}

.placeholder-text {
  color: #9ca3af;
  font-style: italic;
  width: 100%;
  text-align: center;
}

.sentence-word {
  padding: 0.5rem 1rem;
  background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%);
  color: white;
  border-radius: 0.375rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
}

.sentence-word:hover {
  transform: scale(1.05);
  box-shadow: 0 2px 6px rgba(220, 38, 38, 0.4);
}

/* Matching game styles */
.matching-word-btn:hover:not(:disabled):not(.matched) {
  border-color: #dc2626 !important;
  background: #fef2f2 !important;
  transform: translateX(5px);
  box-shadow: 0 4px 12px rgba(220, 38, 38, 0.2);
}

.matching-word-btn.selected {
  border-color: #dc2626 !important;
  background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%) !important;
  color: white !important;
  transform: scale(1.05);
  box-shadow: 0 6px 16px rgba(220, 38, 38, 0.4);
}

.matching-word-btn.matched {
  opacity: 0.4;
  cursor: not-allowed !important;
  background: #f3f4f6 !important;
  border-color: #d1d5db !important;
}

.matching-word-btn.correct-match {
  border-color: #10b981 !important;
  background: #d1fae5 !important;
  color: #065f46 !important;
  animation: matchPulse 0.5s ease;
}

@keyframes matchPulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.1); }
}

@keyframes shake {
  0%, 100% { transform: translateX(0); }
  10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
  20%, 40%, 60%, 80% { transform: translateX(5px); }
}

@media (max-width: 768px) {
  .matching-game {
    grid-template-columns: 1fr !important;
  }

  .info-grid {
    grid-template-columns: 1fr;
    gap: 1rem;
  }

  .info-item {
    padding: 0.75rem;
  }

  .info-item i {
    font-size: 1.5rem;
  }

  .info-value {
    font-size: 1.5rem;
  }
}
</style>
{% endblock %}

{% block lesson_content %}
<!-- CSRF Token –¥–ª—è AJAX –∑–∞–ø—Ä–æ—Å–æ–≤ -->
<meta name="csrf-token" content="{{ csrf_token() }}">

<div class="checkpoint-lesson">
  <!-- –°—Ç–∞—Ä—Ç–æ–≤—ã–π —ç–∫—Ä–∞–Ω -->
  <div class="final-test-screen" id="start-screen">
    <div class="checkpoint-start-content">
      <div class="checkpoint-icon">
        <i class="fas fa-clipboard-check"></i>
      </div>
      <h2>{{ _('–§–∏–Ω–∞–ª—å–Ω—ã–π —Ç–µ—Å—Ç') }}</h2>
      <p class="text-muted mb-4">
        {{ _('–§–∏–Ω–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –∑–Ω–∞–Ω–∏–π –ø–æ –º–æ–¥—É–ª—é.') }}<br>
        {{ _('–û—Ç–≤–µ—Ç—å—Ç–µ –Ω–∞ –≤—Å–µ –≤–æ–ø—Ä–æ—Å—ã –≤–Ω–∏–º–∞—Ç–µ–ª—å–Ω–æ.') }}
      </p>

      <!-- –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Ç–µ—Å—Ç–µ -->
      <div class="checkpoint-info">
        <div class="info-grid">
          <div class="info-item">
            <i class="fas fa-question-circle"></i>
            <div>
              <span class="info-value">{{ exercises|length }}</span>
              <span class="info-label">{{ _('–í–æ–ø—Ä–æ—Å–æ–≤') }}</span>
            </div>
          </div>
          <div class="info-item">
            <i class="fas fa-percentage"></i>
            <div>
              <span class="info-value">{{ passing_score }}%</span>
              <span class="info-label">{{ _('–ü—Ä–æ—Ö–æ–¥–Ω–æ–π –±–∞–ª–ª') }}</span>
            </div>
          </div>
          <div class="info-item">
            <i class="fas fa-clock"></i>
            <div>
              <span class="info-value">~{{ ((exercises|length * 1.5)|round)|int }}</span>
              <span class="info-label">{{ _('–ú–∏–Ω—É—Ç') }}</span>
            </div>
          </div>
        </div>
      </div>

      <!-- –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ -->
      <div class="checkpoint-warning">
        <i class="fas fa-exclamation-triangle"></i>
        <p>{{ _('–í—ã —É–≤–∏–¥–∏—Ç–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ—Å–ª–µ –ø—Ä–æ—Ö–æ–∂–¥–µ–Ω–∏—è –≤—Å–µ—Ö –≤–æ–ø—Ä–æ—Å–æ–≤. –û—Ç–≤–µ—á–∞–π—Ç–µ –≤–Ω–∏–º–∞—Ç–µ–ª—å–Ω–æ!') }}</p>
      </div>

      <button type="button" id="start-final-test-btn">
        <i class="fas fa-play"></i> {{ _('–ù–∞—á–∞—Ç—å —Ç–µ—Å—Ç') }}
      </button>
    </div>
  </div>

  <!-- –≠–∫—Ä–∞–Ω –≤–æ–ø—Ä–æ—Å–æ–≤ -->
  <div class="final-test-screen" id="test-screen" style="display: none;">
    <!-- –ü—Ä–æ–≥—Ä–µ—Å—Å —Ç–µ—Å—Ç–∞ -->
    <div class="final-test-progress-section mb-4">
      <div class="progress-info">
        <span>{{ _('–í–æ–ø—Ä–æ—Å') }} <span id="current-num">1</span> {{ _('–∏–∑') }} {{ exercises|length }}</span>
      </div>
      <div class="final-test-progress-bar">
        <div class="final-test-progress-fill" id="test-progress-bar" style="width: 0%"></div>
      </div>
    </div>

    <!-- –§–æ—Ä–º–∞ —Å –≤–æ–ø—Ä–æ—Å–∞–º–∏ -->
    <!-- –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è –≤–æ–ø—Ä–æ—Å–æ–≤ -->
    <div class="questions-container">
      {% for question in exercises %}
        {% set question_index = loop.index0 %}
        <div class="question-card" id="question-{{ question_index }}" style="display: none;" data-index="{{ question_index }}">
          {% set full_question = question.question or question.prompt or question.sentence or question.russian %}

          {# Check if it's a dialogue question (contains A: and B:) #}
          {% if "A:" in full_question and "B:" in full_question %}
            {% set dialogue_parts = full_question.split("B:") %}
            {% set person_a = dialogue_parts[0].replace("A:", "").strip().strip("'\"") %}
            {% set person_b_incomplete = dialogue_parts[1].strip().strip("'\"") %}

            <div class="dialogue-question" style="margin-bottom: 1.5rem;">
              <div class="dialogue-line" style="padding: 1rem; background: linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 100%); border-radius: 0.75rem; margin-bottom: 0.75rem;">
                <span style="font-weight: 700; color: #dc2626;">A:</span>
                <span style="margin-left: 0.5rem; color: #1f2937;">{{ person_a }}</span>
              </div>
              <div class="dialogue-line" style="padding: 1rem; background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%); border-radius: 0.75rem; position: relative;">
                <span style="font-weight: 700; color: #dc2626;">B:</span>
                <span style="margin-left: 0.5rem; color: #92400e; font-style: italic;">{{ person_b_incomplete }}</span>
              </div>
            </div>
          {% else %}
            <h3 class="question-text">{{ full_question }}</h3>
          {% endif %}

          {% if question.type == 'multiple_choice' and question.options %}
            <div class="answer-options">
              {% for option in question.options %}
                <button type="button"
                        class="answer-option"
                        data-question="{{ question_index }}"
                        data-value="{{ loop.index0 }}"
                        data-text="{{ option }}">
                  <span class="option-letter">{{ 'ABCD'[loop.index0] }}</span>
                  <span class="option-text">{{ option }}</span>
                </button>
              {% endfor %}
            </div>

          {% elif question.type == 'true_false' %}
            <div class="answer-options">
              <button type="button"
                      class="answer-option"
                      data-question="{{ question_index }}"
                      data-value="true">
                <span class="option-letter">T</span>
                <span class="option-text">{{ _('–í–µ—Ä–Ω–æ') }}</span>
              </button>
              <button type="button"
                      class="answer-option"
                      data-question="{{ question_index }}"
                      data-value="false">
                <span class="option-letter">F</span>
                <span class="option-text">{{ _('–ù–µ–≤–µ—Ä–Ω–æ') }}</span>
              </button>
            </div>

          {% elif question.type in ['fill_in_blank', 'fill_blank', 'translation'] %}
            {# Check input_mode to determine whether to show options or text input #}
            {% set show_as_options = question.options or (lesson.input_mode in ['selection_only', 'selection_and_ordering']) %}
            {% set allow_text_input = lesson.input_mode in ['mixed', 'advanced'] and question.type != 'translation' %}
            {% set allow_translation = lesson.input_mode == 'advanced' and question.type == 'translation' %}

            {% if show_as_options and question.options %}
              <!-- Fill blank with options (multiple choice style) -->
              <div class="answer-options">
                {% for option in question.options %}
                  <button type="button"
                          class="answer-option"
                          data-question="{{ question_index }}"
                          data-value="{{ loop.index0 }}"
                          data-text="{{ option }}">
                    <span class="option-letter">{{ 'ABCD'[loop.index0] }}</span>
                    <span class="option-text">{{ option }}</span>
                  </button>
                {% endfor %}
              </div>
            {% elif allow_text_input or allow_translation %}
              <!-- Fill blank/translation with text input -->
              <div class="text-answer">
                <input type="text"
                       class="form-control"
                       id="text-answer-{{ question_index }}"
                       placeholder="{{ _('–í–≤–µ–¥–∏—Ç–µ –≤–∞—à –æ—Ç–≤–µ—Ç...') }}">
                <button type="button"
                        class="btn btn-danger text-submit-btn"
                        data-question="{{ question_index }}">
                  {{ _('–û—Ç–ø—Ä–∞–≤–∏—Ç—å –æ—Ç–≤–µ—Ç') }}
                </button>
              </div>
            {% else %}
              <!-- Fallback: input mode doesn't allow this question type -->
              <div class="alert alert-warning">
                <i class="fas fa-exclamation-triangle"></i>
                {{ _('–≠—Ç–æ—Ç —Ç–∏–ø –≤–æ–ø—Ä–æ—Å–∞ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ —Ä–µ–∂–∏–º–∞ –º–æ–¥—É–ª—è') }}
              </div>
            {% endif %}
              
          {% elif question.type == 'transformation' %}
            <div class="transformation-answer">
              {% set full_question = question.question or '' %}
              {% set instruction = question.instruction or '' %}
              {% set sentence = question.sentence or '' %}

              {# If we have full question but no separate instruction/sentence, try to parse it #}
              {% if full_question and not sentence %}
                {% if ':' in full_question %}
                  {% set parts = full_question.split(':', 1) %}
                  {% set instruction = parts[0].strip() %}
                  {% set sentence = parts[1].strip() %}
                {% else %}
                  {% set sentence = full_question %}
                {% endif %}
              {% endif %}

              {% if instruction %}
                <p class="instruction-text" style="font-size: 1rem; color: #6b7280; margin-bottom: 1rem; padding: 1rem; background: #f9fafb; border-left: 4px solid #dc2626; border-radius: 0.5rem;">
                  {{ instruction }}
                </p>
              {% endif %}
              {% if sentence %}
                <p class="source-sentence" style="font-size: 1.2rem; font-weight: 600; padding: 1.5rem; background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%); color: #92400e; border-radius: 0.75rem; text-align: center; margin-bottom: 1.5rem;">
                  {{ sentence }}
                </p>
              {% endif %}
              <input type="text"
                     class="form-control"
                     id="text-answer-{{ question_index }}"
                     placeholder="{{ _('–í–≤–µ–¥–∏—Ç–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–Ω–æ–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ...') }}">
              <button type="button"
                      class="btn btn-danger mt-3 text-submit-btn"
                      data-question="{{ question_index }}">
                {{ _('–û—Ç–ø—Ä–∞–≤–∏—Ç—å –æ—Ç–≤–µ—Ç') }}
              </button>
            </div>

          {% elif question.type == 'matching' %}
            <div class="matching-answer">
              {% if question.instruction %}
                <p class="instruction-text" style="font-size: 1rem; color: #6b7280; margin-bottom: 1.5rem; padding: 1rem; background: #f9fafb; border-left: 4px solid #dc2626; border-radius: 0.5rem;">
                  üí° {{ question.instruction }}
                </p>
              {% endif %}

              <p style="font-size: 0.95rem; color: #6b7280; text-align: center; margin-bottom: 1.5rem;">
                {{ _('–ö–ª–∏–∫–Ω–∏—Ç–µ –Ω–∞ —Å–ª–æ–≤–æ —Å–ª–µ–≤–∞, –∑–∞—Ç–µ–º –Ω–∞ –µ–≥–æ –ø–µ—Ä–µ–≤–æ–¥ —Å–ø—Ä–∞–≤–∞') }}
              </p>

              <div class="matching-game" style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem;">
                <!-- Left column (English) -->
                <div class="matching-left-column" id="matching-left-{{ question_index }}">
                  {% for pair in question.pairs %}
                    <button type="button"
                            class="matching-word-btn left-word"
                            data-question="{{ question_index }}"
                            data-pair-id="{{ loop.index0 }}"
                            data-word="{{ pair.english or pair.left }}"
                            onclick="selectLeftWord({{ question_index }}, {{ loop.index0 }}, this)"
                            style="display: block; width: 100%; padding: 1rem; margin-bottom: 0.75rem; background: white; border: 2px solid #e5e7eb; border-radius: 0.75rem; text-align: left; font-size: 1.05rem; font-weight: 600; color: #1f2937; cursor: pointer; transition: all 0.3s;">
                      {{ pair.english or pair.left }}
                    </button>
                  {% endfor %}
                </div>

                <!-- Right column (Russian) - shuffled -->
                <div class="matching-right-column" id="matching-right-{{ question_index }}">
                  {% set shuffled_pairs = question.pairs|list %}
                  {# Simple shuffle: reverse for now, in real app would use random #}
                  {% for pair in shuffled_pairs|reverse %}
                    <button type="button"
                            class="matching-word-btn right-word"
                            data-question="{{ question_index }}"
                            data-pair-id="{{ (question.pairs|length - loop.index) }}"
                            data-word="{{ pair.russian or pair.right }}"
                            onclick="selectRightWord({{ question_index }}, {{ (question.pairs|length - loop.index) }}, this)"
                            style="display: block; width: 100%; padding: 1rem; margin-bottom: 0.75rem; background: white; border: 2px solid #e5e7eb; border-radius: 0.75rem; text-align: right; font-size: 1.05rem; font-weight: 600; color: #1f2937; cursor: pointer; transition: all 0.3s;">
                      {{ pair.russian or pair.right }}
                    </button>
                  {% endfor %}
                </div>
              </div>

              <button type="button"
                      class="btn btn-danger mt-3 matching-submit-btn"
                      id="matching-submit-{{ question_index }}"
                      data-question="{{ question_index }}"
                      onclick="submitMatchingAnswer({{ question_index }})"
                      style="width: 100%; display: none;">
                {{ _('–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å') }}
              </button>
            </div>

          {% elif question.type == 'reorder' %}
            <div class="reorder-answer">
              <p class="instruction-text">
                üî§ {{ _('–ö–ª–∏–∫–∞–π—Ç–µ –Ω–∞ —Å–ª–æ–≤–∞ –¥–ª—è —Å–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è') }}
              </p>
              <div class="words-container" id="words-container-{{ question_index }}">
                {% for word in question.words %}
                  <button type="button"
                          class="word-button"
                          data-word="{{ word }}"
                          onclick="addWordToSentence({{ question_index }}, '{{ word }}', this)">
                    {{ word }}
                  </button>
                {% endfor %}
              </div>
              <div class="sentence-container">
                <div class="sentence-display" id="sentence-{{ question_index }}"
                     onclick="clearSentence({{ question_index }})">
                  <span class="placeholder-text">{{ _('–ù–∞–∂–º–∏—Ç–µ –Ω–∞ —Å–ª–æ–≤–∞ –≤—ã—à–µ, —á—Ç–æ–±—ã —Å–æ—Å—Ç–∞–≤–∏—Ç—å –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ') }}</span>
                </div>
              </div>
              <button type="button"
                      class="btn btn-danger mt-3 reorder-submit-btn"
                      data-question="{{ question_index }}"
                      onclick="submitReorderAnswer({{ question_index }})">
                {{ _('–û—Ç–ø—Ä–∞–≤–∏—Ç—å –æ—Ç–≤–µ—Ç') }}
              </button>
            </div>
          {% endif %}

          <!-- –û–±—Ä–∞—Ç–Ω–∞—è —Å–≤—è–∑—å -->
          <div class="question-feedback" id="feedback-{{ question_index }}" style="display: none;">
            <div class="feedback-content">
              <div class="feedback-icon"></div>
              <div class="feedback-text"></div>
            </div>
            <button type="button" class="btn btn-danger mt-2" onclick="FinalTestApp.nextQuestion()" style="width: 100%; padding: 0.5rem 1rem; font-size: 0.9rem;">
              <span class="btn-text">{{ _('–°–ª–µ–¥—É—é—â–∏–π –≤–æ–ø—Ä–æ—Å') }}</span>
              <i class="fas fa-arrow-right ms-1"></i>
            </button>
          </div>
        </div>
      {% endfor %}
    </div>
  </div>
</div>

<script>
// Final Test data
window.finalTestData = {
  questions: {{ exercises|tojson|safe }},
  totalQuestions: {{ exercises|length }},
  passingScore: {{ passing_score }}
};

// Reorder exercise functions (from quiz.html)
function addWordToSentence(questionIndex, word, button) {
  const sentenceDiv = document.getElementById(`sentence-${questionIndex}`);
  const placeholder = sentenceDiv.querySelector('.placeholder-text');

  if (placeholder) {
    placeholder.remove();
  }

  const wordElement = document.createElement('span');
  wordElement.className = 'sentence-word';
  wordElement.textContent = word;
  wordElement.onclick = () => removeWordFromSentence(wordElement, button);

  sentenceDiv.appendChild(wordElement);

  if (!word.match(/[.,!?;]/)) {
    const space = document.createElement('span');
    space.textContent = ' ';
    space.className = 'word-space';
    sentenceDiv.appendChild(space);
  }

  button.disabled = true;
  button.classList.add('used');
}

function removeWordFromSentence(wordElement, originalButton) {
  originalButton.disabled = false;
  originalButton.classList.remove('used');

  const nextElement = wordElement.nextSibling;
  if (nextElement && nextElement.classList && nextElement.classList.contains('word-space')) {
    nextElement.remove();
  }
  wordElement.remove();

  const sentenceDiv = wordElement.parentElement || document.getElementById(`sentence-${FinalTestApp.state.currentQuestion}`);
  if (sentenceDiv && !sentenceDiv.textContent.trim()) {
    const placeholder = document.createElement('span');
    placeholder.className = 'placeholder-text';
    placeholder.textContent = '{{ _("–ù–∞–∂–º–∏—Ç–µ –Ω–∞ —Å–ª–æ–≤–∞ –≤—ã—à–µ, —á—Ç–æ–±—ã —Å–æ—Å—Ç–∞–≤–∏—Ç—å –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ") }}';
    sentenceDiv.appendChild(placeholder);
  }
}

function clearSentence(questionIndex) {
  const sentenceDiv = document.getElementById(`sentence-${questionIndex}`);
  const wordsContainer = document.getElementById(`words-container-${questionIndex}`);

  const wordButtons = wordsContainer.querySelectorAll('.word-button');
  wordButtons.forEach(button => {
    button.disabled = false;
    button.classList.remove('used');
  });

  sentenceDiv.innerHTML = '<span class="placeholder-text">{{ _("–ù–∞–∂–º–∏—Ç–µ –Ω–∞ —Å–ª–æ–≤–∞ –≤—ã—à–µ, —á—Ç–æ–±—ã —Å–æ—Å—Ç–∞–≤–∏—Ç—å –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ") }}</span>';
}

function submitReorderAnswer(questionIndex) {
  const sentenceDiv = document.getElementById(`sentence-${questionIndex}`);
  const placeholder = sentenceDiv.querySelector('.placeholder-text');

  if (placeholder) {
    sentenceDiv.classList.add('error');
    setTimeout(() => sentenceDiv.classList.remove('error'), 1000);
    return;
  }

  const sentence = sentenceDiv.textContent.trim();

  FinalTestApp.state.answers[questionIndex] = {
    value: sentence,
    text: sentence,
    correct: false
  };

  const question = window.finalTestData.questions[questionIndex];
  const correctAnswer = question.correct_answer || question.correct || question.answer || '';

  const normalize = (text) => text ? text.toLowerCase().replace(/[^\w\s]/g, '').replace(/\s+/g, ' ').trim() : '';
  const isCorrect = normalize(sentence) === normalize(correctAnswer);

  FinalTestApp.state.answers[questionIndex].correct = isCorrect;

  const wordsContainer = document.getElementById(`words-container-${questionIndex}`);
  const wordButtons = wordsContainer.querySelectorAll('.word-button');
  wordButtons.forEach(button => button.disabled = true);

  const submitBtn = document.querySelector(`.reorder-submit-btn[data-question="${questionIndex}"]`);
  submitBtn.disabled = true;

  FinalTestApp.showFeedback(questionIndex, isCorrect, correctAnswer);
}

// Matching game state
const matchingState = {};

function selectLeftWord(questionIndex, pairId, button) {
  if (button.classList.contains('matched')) return;

  // Initialize state if needed
  if (!matchingState[questionIndex]) {
    matchingState[questionIndex] = {
      selectedLeft: null,
      selectedRight: null,
      matchedPairs: []
    };
  }

  const state = matchingState[questionIndex];

  // Deselect previous left selection
  document.querySelectorAll(`.left-word[data-question="${questionIndex}"]`).forEach(btn => {
    if (!btn.classList.contains('matched')) {
      btn.classList.remove('selected');
    }
  });

  // Select this button
  button.classList.add('selected');
  state.selectedLeft = { pairId, button };

  // If right is already selected, try to match
  if (state.selectedRight) {
    checkMatch(questionIndex);
  }
}

function selectRightWord(questionIndex, pairId, button) {
  if (button.classList.contains('matched')) return;

  const state = matchingState[questionIndex];
  if (!state) return;

  // Deselect previous right selection
  document.querySelectorAll(`.right-word[data-question="${questionIndex}"]`).forEach(btn => {
    if (!btn.classList.contains('matched')) {
      btn.classList.remove('selected');
    }
  });

  // Select this button
  button.classList.add('selected');
  state.selectedRight = { pairId, button };

  // If left is already selected, try to match
  if (state.selectedLeft) {
    checkMatch(questionIndex);
  }
}

function checkMatch(questionIndex) {
  const state = matchingState[questionIndex];
  const leftBtn = state.selectedLeft.button;
  const rightBtn = state.selectedRight.button;

  // Check if pair IDs match
  if (state.selectedLeft.pairId === state.selectedRight.pairId) {
    // Correct match!
    leftBtn.classList.remove('selected');
    rightBtn.classList.remove('selected');
    leftBtn.classList.add('matched', 'correct-match');
    rightBtn.classList.add('matched', 'correct-match');

    // Add to matched list
    state.matchedPairs.push({
      left: leftBtn.dataset.word,
      right: rightBtn.dataset.word
    });

    // Move matched buttons to the top of their columns
    const leftColumn = document.getElementById(`matching-left-${questionIndex}`);
    const rightColumn = document.getElementById(`matching-right-${questionIndex}`);

    // Prepend (move to top)
    leftColumn.prepend(leftBtn);
    rightColumn.prepend(rightBtn);

    // Check if all pairs are matched
    const question = window.finalTestData.questions[questionIndex];
    if (state.matchedPairs.length === question.pairs.length) {
      // All matched! Show submit button
      document.getElementById(`matching-submit-${questionIndex}`).style.display = 'block';
    }
  } else {
    // Wrong match - shake and deselect
    leftBtn.style.animation = 'shake 0.5s';
    rightBtn.style.animation = 'shake 0.5s';

    setTimeout(() => {
      leftBtn.classList.remove('selected');
      rightBtn.classList.remove('selected');
      leftBtn.style.animation = '';
      rightBtn.style.animation = '';
    }, 500);
  }

  // Reset selections
  state.selectedLeft = null;
  state.selectedRight = null;
}

function submitMatchingAnswer(questionIndex) {
  // For matching questions, we just mark them as correct (they're educational, not test)
  FinalTestApp.state.answers[questionIndex] = {
    value: 'completed',
    text: '–°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è –Ω–∞–π–¥–µ–Ω—ã',
    correct: true
  };

  FinalTestApp.state.correctCount++;

  const submitBtn = document.getElementById(`matching-submit-${questionIndex}`);
  submitBtn.disabled = true;

  // Show simplified feedback for matching
  FinalTestApp.showFeedback(questionIndex, true, null);
}

// Final Test App
window.FinalTestApp = {
  state: {
    currentQuestion: 0,
    answers: [],
    correctCount: 0,
    started: false
  },

  init() {
    document.getElementById('start-final-test-btn')?.addEventListener('click', () => this.startTest());

    document.querySelectorAll('.answer-option').forEach(btn => {
      btn.addEventListener('click', (e) => this.selectAnswer(e.target.closest('.answer-option')));
    });

    document.querySelectorAll('.text-submit-btn').forEach(btn => {
      btn.addEventListener('click', () => this.submitTextAnswer(parseInt(btn.dataset.question)));
    });
  },

  startTest() {
    const startScreen = document.getElementById('start-screen');
    const testScreen = document.getElementById('test-screen');

    if (startScreen) startScreen.style.display = 'none';
    if (testScreen) testScreen.style.display = 'block';
    this.state.started = true;

    // Restore progress if exists
    {% if progress and progress.data and progress.status != 'completed' %}
      const savedData = {{ progress.data|tojson|safe }};
      if (savedData.current_question !== undefined) {
        this.state.currentQuestion = savedData.current_question;
        this.state.answers = savedData.answers || [];
        this.state.correctCount = savedData.correct_count || 0;
      }
    {% endif %}

    this.updateProgress();
    this.showQuestion(this.state.currentQuestion);
  },

  showQuestion(index) {
    document.querySelectorAll('.question-card').forEach(card => card.style.display = 'none');
    const currentCard = document.getElementById(`question-${index}`);
    if (currentCard) {
      currentCard.style.display = 'block';
      currentCard.querySelectorAll('.answer-option').forEach(btn => {
        btn.classList.remove('selected', 'correct', 'incorrect');
        btn.disabled = false;
      });
      const textarea = currentCard.querySelector('input[type="text"]');
      if (textarea) {
        textarea.value = '';
        textarea.disabled = false;
      }
      const feedbackElement = document.getElementById(`feedback-${index}`);
      if (feedbackElement) {
        feedbackElement.style.display = 'none';
      }
      this.updateProgress();
    }
  },

  selectAnswer(button) {
    const questionIndex = parseInt(button.dataset.question);
    const value = button.dataset.value;
    const text = button.dataset.text || value;

    button.closest('.answer-options').querySelectorAll('.answer-option').forEach(btn => {
      btn.disabled = true;
    });

    const question = window.finalTestData.questions[questionIndex];

    let correctAnswer = null;
    if (question.correct_index !== undefined) {
      correctAnswer = question.correct_index;
    } else if (question.correct !== undefined) {
      correctAnswer = question.correct;
    } else if (question.answer !== undefined) {
      correctAnswer = question.answer;
    } else if (question.correct_answer !== undefined) {
      correctAnswer = question.correct_answer;
    }

    let isCorrect = false;

    if (question.type === 'true_false') {
      if (typeof correctAnswer === 'boolean') {
        isCorrect = (value === 'true') === correctAnswer;
      } else if (typeof correctAnswer === 'string') {
        isCorrect = value === correctAnswer;
      } else {
        isCorrect = (value === 'true') === (correctAnswer == true);
      }
    } else if (question.type === 'multiple_choice' || (question.type === 'fill_in_blank' && question.options) || (question.type === 'fill_blank' && question.options)) {
      const userIndex = parseInt(value);
      const normalize = (str) => str ? str.toLowerCase().trim() : '';

      if (typeof correctAnswer === 'string' && !correctAnswer.match(/^\d+$/)) {
        const correctIndex = question.options.findIndex(opt => normalize(opt) === normalize(correctAnswer));
        isCorrect = userIndex === correctIndex;
      } else {
        const correctIndex = typeof correctAnswer === 'string' ? parseInt(correctAnswer) : correctAnswer;
        isCorrect = userIndex === correctIndex;
      }
    } else {
      isCorrect = parseInt(value) === correctAnswer;
    }

    button.classList.add('selected');
    if (isCorrect) {
      button.classList.add('correct');
    } else {
      button.classList.add('incorrect');

      const normalize = (str) => str ? str.toLowerCase().trim() : '';
      const correctIndex = typeof correctAnswer === 'string' && !correctAnswer.match(/^\d+$/)
        ? question.options.findIndex(opt => normalize(opt) === normalize(correctAnswer))
        : (typeof correctAnswer === 'string' ? parseInt(correctAnswer) : correctAnswer);

      const correctButton = button.closest('.answer-options').querySelector(`.answer-option[data-value="${correctIndex}"]`);
      if (correctButton) {
        correctButton.classList.add('correct');
      }
    }

    // Save answer TEXT, not index (for questions with options)
    this.state.answers[questionIndex] = {
      value: text,  // Changed from 'value' to 'text' - save the actual answer text
      text: text,
      correct: isCorrect
    };

    if (isCorrect) {
      this.state.correctCount++;
    }

    this.showFeedback(questionIndex, isCorrect, correctAnswer);
  },

  submitTextAnswer(questionIndex) {
    const input = document.getElementById(`text-answer-${questionIndex}`);
    const answer = input.value.trim();

    if (!answer) {
      input.classList.add('is-invalid');
      return;
    }

    input.disabled = true;
    document.querySelector(`.text-submit-btn[data-question="${questionIndex}"]`).disabled = true;

    const question = window.finalTestData.questions[questionIndex];
    let correctAnswer = question.correct_answer || question.answer || question.correct;

    const normalize = (text) => {
      if (!text) return '';
      return text.toLowerCase()
        .replace(/[^\w\s–∞-—è—ë–ê-–Ø–Å]/gi, '')
        .replace(/\s+/g, ' ')
        .trim();
    };

    let isCorrect = false;
    if (Array.isArray(correctAnswer)) {
      isCorrect = correctAnswer.some(ans => normalize(ans) === normalize(answer));
    } else {
      isCorrect = normalize(answer) === normalize(correctAnswer);
    }

    if (!isCorrect && question.alternative_answers) {
      isCorrect = question.alternative_answers.some(ans => normalize(ans) === normalize(answer));
    }

    if (!isCorrect && question.acceptable_answers) {
      isCorrect = question.acceptable_answers.some(ans => normalize(ans) === normalize(answer));
    }

    this.state.answers[questionIndex] = {
      value: answer,
      text: answer,
      correct: isCorrect
    };

    if (isCorrect) {
      this.state.correctCount++;
    }

    this.showFeedback(questionIndex, isCorrect, correctAnswer);
  },

  saveProgressDebounced: null,
  saveProgressTimer: null,

  async saveProgress() {
    // Debounce - don't save too frequently (wait 1 second)
    if (this.saveProgressTimer) {
      clearTimeout(this.saveProgressTimer);
    }

    this.saveProgressTimer = setTimeout(async () => {
      const csrfToken = document.querySelector('meta[name="csrf-token"]');

      try {
        const response = await fetch('{{ url_for("curriculum_lessons.update_lesson_progress", lesson_id=lesson.id) }}', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrfToken ? csrfToken.content : ''
          },
          body: JSON.stringify({
            status: 'in_progress',
            data: {
              current_question: this.state.currentQuestion,
              answers: this.state.answers,
              correct_count: this.state.correctCount,
              total_questions: window.finalTestData.totalQuestions
            }
          })
        });

        if (!response.ok) {
          console.error('Failed to save progress');
        }
      } catch (error) {
        console.error('Error saving progress:', error);
      }
    }, 1000); // Wait 1 second before saving
  },

  showFeedback(questionIndex, isCorrect, correctAnswer) {
    const feedbackEl = document.getElementById(`feedback-${questionIndex}`);
    const iconEl = feedbackEl.querySelector('.feedback-icon');
    const textEl = feedbackEl.querySelector('.feedback-text');
    const question = window.finalTestData.questions[questionIndex];
    const userAnswer = this.state.answers[questionIndex];

    if (isCorrect) {
      feedbackEl.className = 'question-feedback correct';
      iconEl.innerHTML = '<i class="fas fa-check-circle"></i>';
      textEl.innerHTML = '<strong>{{ _("–ü—Ä–∞–≤–∏–ª—å–Ω–æ!") }}</strong>';
    } else {
      feedbackEl.className = 'question-feedback incorrect';
      iconEl.innerHTML = '<i class="fas fa-times-circle"></i>';

      let correctText = '';
      let userText = userAnswer ? userAnswer.text : '';

      if ((question.type === 'multiple_choice' || question.type === 'fill_in_blank' || question.type === 'fill_blank') && question.options) {
        if (typeof correctAnswer === 'number' && correctAnswer >= 0 && correctAnswer < question.options.length) {
          correctText = question.options[correctAnswer];
        } else if (typeof correctAnswer === 'string' && correctAnswer.match(/^\d+$/)) {
          const index = parseInt(correctAnswer);
          if (index >= 0 && index < question.options.length) {
            correctText = question.options[index];
          } else {
            correctText = correctAnswer;
          }
        } else {
          correctText = correctAnswer;
        }
      } else if (question.type === 'true_false') {
        if (typeof correctAnswer === 'boolean') {
          correctText = correctAnswer ? '{{ _("–í–µ—Ä–Ω–æ") }}' : '{{ _("–ù–µ–≤–µ—Ä–Ω–æ") }}';
        } else if (typeof correctAnswer === 'string') {
          correctText = (correctAnswer === 'true' || correctAnswer === true) ? '{{ _("–í–µ—Ä–Ω–æ") }}' : '{{ _("–ù–µ–≤–µ—Ä–Ω–æ") }}';
        } else {
          correctText = correctAnswer ? '{{ _("–í–µ—Ä–Ω–æ") }}' : '{{ _("–ù–µ–≤–µ—Ä–Ω–æ") }}';
        }
      } else {
        if (Array.isArray(correctAnswer)) {
          correctText = correctAnswer.join(' / ');
        } else {
          correctText = correctAnswer || '{{ _("–û—Ç–≤–µ—Ç –Ω–µ —É–∫–∞–∑–∞–Ω") }}';
        }
      }

      textEl.innerHTML = `<strong>{{ _("–ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ") }}</strong><br>`;

      const hideUserAnswer = ['reorder'].includes(question.type);

      if (userText && !hideUserAnswer) {
        textEl.innerHTML += `{{ _("–í–∞—à –æ—Ç–≤–µ—Ç:") }} <strong>${userText}</strong><br>`;
      }
      textEl.innerHTML += `{{ _("–ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç:") }} <strong>${correctText}</strong>`;

      if (question.explanation) {
        textEl.innerHTML += `<br><br><strong>{{ _("–û–±—ä—è—Å–Ω–µ–Ω–∏–µ:") }}</strong> ${question.explanation}`;
      }
    }

    const isLastQuestion = questionIndex >= window.finalTestData.totalQuestions - 1;
    feedbackEl.querySelector('.btn-text').textContent = isLastQuestion ? '{{ _("–ü–æ–∫–∞–∑–∞—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã") }}' : '{{ _("–°–ª–µ–¥—É—é—â–∏–π –≤–æ–ø—Ä–æ—Å") }}';

    feedbackEl.style.display = 'block';
  },

  nextQuestion() {
    // Save progress before moving to next question
    this.saveProgress();

    this.state.currentQuestion++;

    if (this.state.currentQuestion >= window.finalTestData.totalQuestions) {
      this.submitResults();
    } else {
      this.showQuestion(this.state.currentQuestion);
    }
  },

  updateProgress() {
    const currentNum = this.state.currentQuestion + 1;
    const percent = (currentNum / window.finalTestData.totalQuestions) * 100;
    document.getElementById('test-progress-bar').style.width = percent + '%';
    document.getElementById('current-num').textContent = currentNum;
  },

  submitResults() {
    // Create a hidden form and submit it (traditional POST)
    const form = document.createElement('form');
    form.method = 'POST';
    form.action = window.location.href;

    // Add CSRF token
    const csrfToken = document.querySelector('meta[name="csrf-token"]');
    if (csrfToken) {
      const csrfInput = document.createElement('input');
      csrfInput.type = 'hidden';
      csrfInput.name = 'csrf_token';
      csrfInput.value = csrfToken.content;
      form.appendChild(csrfInput);
    }

    // Add all answers
    for (let i = 0; i < window.finalTestData.totalQuestions; i++) {
      const answer = this.state.answers[i];
      if (answer) {
        const input = document.createElement('input');
        input.type = 'hidden';
        input.name = `answer_${i}`;
        input.value = answer.value;
        form.appendChild(input);
      }
    }

    // Append form to body and submit
    document.body.appendChild(form);
    form.submit();
  }
};

document.addEventListener('DOMContentLoaded', () => {
  FinalTestApp.init();

  // Auto-start test if there's saved progress (not completed)
  {% if progress and progress.data and progress.status != 'completed' %}
    const savedData = {{ progress.data|tojson|safe }};
    // Auto-start if there's any saved data (current_question or answers exist)
    if (savedData && (savedData.current_question !== undefined || (savedData.answers && savedData.answers.length > 0))) {
      console.log('Auto-starting final test with saved progress:', savedData);
      FinalTestApp.startTest();
    }
  {% endif %}
});
</script>
{% endblock %}

